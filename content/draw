TITLE=Draw
CATEGORY=40:Web Tools
DESC=Drawing tool with symmetry
NOMENU
ORDER=20
==
<p><a href='index.html'>Home</a></p>

<style>
    #canvas {
        border: 1px solid white;
        background-color: black;
        touch-action: none;
    }
</style>
<canvas id='canvas' width=800 height=800></canvas>
<p>
    <input type='color' id='colour' name='colour' value='#000000'>
    <input type='checkbox' id='rainbow'>
    <label for='rainbow'>Rainbow</label>
</p>
<p>
    MODE:
    <input type='radio' id='mode-eight' name='mode' value='8'>
    <label for='mode-eight'>8</label>
    <input type='radio' id='mode-four' name='mode' value='4'>
    <label for='mode-four'>4</label>
    <input type='radio' id='mode-one' name='mode' value='1'>
    <label for='mode-one'>1</label>
</p>
<p>
    BRUSH SIZE:
    <input type='number' id='brush_res' value='1' min='1' max='100'>
</p>
<p><button id='clear' type='button'>CLEAR</button></p>
<p>
    CANVAS SIZE:
    <input type='number' id='canvas_res' value='800' min='10' max='4096'>
    <button id='set_res' type='button'>SET</button>
</p>
<p id='message'></p>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colour = document.getElementById('colour');
    const rainbow = document.getElementById('rainbow');
    const mode = document.getElementsByName('mode');
    const clearBtn = document.getElementById('clear');
    const canvasRes = document.getElementById('canvas_res');
    const setBtn = document.getElementById('set_res');
    const brushRes = document.getElementById('brush_res');
    const message = document.getElementById('message');

    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    let draw = false;
    let currMode = getMode();
    let lastDrawX = null;
    let lastDrawY = null;

    function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function getMode() {
        let selectedMode = null;

        for (let i = 0; i < mode.length; i++) {
            if (mode[i].checked) {
                selectedMode = mode[i].value;
                break;
            }
        }

        return selectedMode;
    }

    function getColour() {
        if (rainbow.checked) {
            let currRed = parseInt('0x'+colour.value.substring(1, 3));
            let currGreen = parseInt('0x'+colour.value.substring(3, 5));
            let currBlue = parseInt('0x'+colour.value.substring(5, 7));

            if (currBlue === 0) {
                if (currGreen === 255) {
                    currGreen--;
                    currBlue++;
                } else {
                    if (currGreen > 0) {
                        currRed--;
                        currGreen++;
                    } else if (currRed === 255) {
                        currRed--;
                        currGreen++;
                    } else {
                        currRed++;
                    }
                }
            } else if (currGreen > 0) {
                currBlue++;
                currGreen--;
            } else {
                currBlue--;
            }

            colour.value = '#'+currRed.toString(16).padStart(2, '0')+currGreen.toString(16).padStart(2, '0')+currBlue.toString(16).padStart(2, '0');
        }

        message.innerHTML = colour.value;

        return colour.value;
    }

    function doDraw(e, type) {
        const rect = canvas.getBoundingClientRect();
        let x = 0;
        let y = 0;

        if (type === 'm') {
            x = parseInt(e.clientX - rect.left);
            y = parseInt(e.clientY - rect.top);
        } else if (type === 't') {
            x = parseInt(e.touches[0].clientX - rect.left);
            y = parseInt(e.touches[0].clientY - rect.top);
        }

        // Use Bresenham's line algorithm to join the gaps in movement points
        if (lastDrawX !== null && lastDrawY !== null) {
            let currX = parseInt(lastDrawX);
            let currY = parseInt(lastDrawY);
            let diffX = Math.abs(x-currX);
            let diffY = Math.abs(y-currY);
            let addX = currX > x ? -1 : 1;
            let addY = currY > y ? -1 : 1;
            let p = 2*diffY-diffX;

            while (currX !== x || currY !== y) {
                if (p < 0) {
                    if (currX !== x) currX += addX;
                    p = p+2*diffY;
                } else {
                    if (currX !== x) currX += addX;
                    if (currY !== y) currY += addY;
                    p = p+2*diffY-2*diffX;
                }

                drawMode(currX, currY, getColour());
            }
        } else {
            drawMode(x, y, getColour());
        }

        lastDrawX = x;
        lastDrawY = y;
    }

    function drawMode(x, y, colour) {
        switch (currMode) {
            case '1':
                drawPoint(x, y, colour);
                break;

            case '4':
                drawFour(x, y, colour);
                break;

            case '8':
                drawEight(x, y, colour);
                break;
        }
    }

    function drawPoint(x, y, colour = '#000000') {
        ctx.fillStyle = colour;
        ctx.beginPath();
        ctx.arc(x, y, brushRes.value, 0, 2 * Math.PI);
        ctx.fill();
    }

    function drawFour(x, y, colour = '#000000') {
        let xm = centerX + (centerX - x);
        let ym = centerY + (centerY - y);

        drawPoint(x ,y, colour);
        drawPoint(xm, y, colour);
        drawPoint(xm, ym, colour);
        drawPoint(x, ym, colour);
    }

    function drawEight(x, y, colour = '#000000') {
        let xm = centerX + (centerX - x);
        let ym = centerY + (centerY - y);

        drawPoint(x ,y, colour);
        drawPoint(xm, y, colour);
        drawPoint(xm, ym, colour);
        drawPoint(x, ym, colour);
        drawPoint(y ,x, colour);
        drawPoint(y, xm, colour);
        drawPoint(ym, xm, colour);
        drawPoint(ym, x, colour);
    }

    clearBtn.addEventListener('click', function (e) {
        clear();
    });

    setBtn.addEventListener('click', function (e) {
        canvas.width = canvasRes.value;
        canvas.height = canvasRes.value;

        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
    });

    canvas.addEventListener('mousemove', function(e) {
        if (draw) {
            doDraw(e, 'm');
        }
    });

    canvas.addEventListener('mousedown', function(e) {
        draw = true;
        doDraw(e, 'm');
    });

    canvas.addEventListener('mouseup', function(e) {
        draw = false;
        lastDrawX = null;
        lastDrawY = null;
    });

    canvas.addEventListener('touchmove', function(e) {
        if (draw) {
            doDraw(e, 't');
        }
    });

    canvas.addEventListener('touchstart', function(e) {
        draw = true;
        doDraw(e, 't');
    });

    canvas.addEventListener('touchend', function(e) {
        draw = false;
        lastDrawX = null;
        lastDrawY = null;
    });

    document.body.addEventListener('touchstart', function (e) {
        if (e.target == canvas) {
            e.preventDefault();
        }
    });

    document.body.addEventListener('touchend', function (e) {
        if (e.target == canvas) {
            e.preventDefault();
        }
    });

    document.body.addEventListener('touchmove', function (e) {
        if (e.target == canvas) {
            e.preventDefault();
        }
    });

    for (let i = 0; i < mode.length; i++) {
        mode[i].addEventListener('change', function (e) {
            currMode = getMode();
        });
    }

    rainbow.addEventListener('change', function (e) {
        if (e.target.checked === true) {
            colour.disabled = true;
            colour.value = '#000000';
        } else {
            colour.disabled = false;
        }
    });
</script>

